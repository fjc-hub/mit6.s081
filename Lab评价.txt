实验目的：
    提供两个接口给进程，实现user-level级别操作虚拟内存（页表）

难点：
    1.在user space中划分出一个专门的区域用于内存映射，不要与heap区域重叠（sbrk系统调用时校验）
    2.mmap在页表中插入新的PTE页表项并设置好读写权限和标志位，VMA关联的“打开的文件”引用计数器加1，扩大进程的“内存映射区域”以便于下一次mmap分配虚拟内存
    3.munmap将某段内存映射VMA从页表中抹除（不支持在原VMA中间抹除，因为会分隔成多个VMA），VMA全部被移除后与VMA关联的“打开的文件”引用计数器减1，需要收缩进程的“内存映射区域”
        当被修改过的页面被抹除/进程调用exit正常退出时，需要先将Page中的更新同步到关联的磁盘文件中。
    4.使用延迟加载Lazy-Allocate机制，内存映射VMA被实际用到时分配物理内存并。用户进程访问Lazy-Allocate的虚拟页时，在内核的Trap处理函数（异常处理函数）中加载并用文件内容初始化
        当内核试图读/写进程的虚拟空间时，需要校验是否读取的Lazy-Allocate Page，Yes则先分配物理内存并初始化后再使用
    5.检查进程的整个生命周期进行适配：进程创建（即fork）时，child需要copy所有parent的内存映射VMA（这里未使用copy-on-write优化的fork），已加载的Page物理复制，未加载的只复制页表PTE即可
        进程退出（即exit）时，释放进程所有的内存映射VMA，已分配物理页的虚拟页需要free物理页面
    6.在内核中新增/删除/修改User-Space的页表项PTE无需手动调用cpu的sfence.vma特权指令，因为kernel-space切换到user-space时会切换CPU当前指向的页表并清空TLB缓存


同一个memory mapped area在读/写一个延迟加载page时 再读/写一个延迟加载page会死锁。这两个操作会锁同一个inode